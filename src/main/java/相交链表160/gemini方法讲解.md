# 解释1

- ### 更精准的比喻：错位补齐

  想象有两条路通向同一个终点：

  - **路 A：** 前面有一段 30 米的独木桥，然后汇入公共大路（50 米）。总长 80 米。
  - **路 B：** 前面有一段 10 米的小路，然后汇入公共大路（50 米）。总长 60 米。

  如果是两个人同时出发，速度一样：

  - 走 B 的人会先走完。
  - 走 A 的人还在独木桥上。

  **这个算法的骚操作在于：** 走 B 的人到了终点后，立刻**瞬移**去走 A 的独木桥； 走 A 的人到了终点后，立刻**瞬移**去走 B 的小路。

  此时，两人走的总路程变成了：

  - **A 指针：** 30(A私有) + 50(公共) + 10(B私有) = 90 米
  - **B 指针：** 10(B私有) + 50(公共) + 30(A私有) = 90 米

  因为**总路程一样**，且**速度一样**，所以他们一定会在最后那段“公共大路”的入口处（也就是交点）**同时到达**。

  ### 总结

  你之前的理解（快慢指针跑圈）是用来**在一个链表里找有没有环**的。 而这道题（双指针互换）是利用**a + c + b = b + c + a** 的数学原理，通过走对方的路来抹平长度差。

  网上对这个解法有一个很浪漫的解释：

  > **“我走过你走过的路，我们最终还是会相遇。”** (前提是：如果依然不相遇，说明我们本来就没缘分——两个链表此时都指向 null)。

# 解释2

- 这个“双指针互换法”（A走完走B，B走完走A）之所以精妙，是因为它用非常简单的逻辑，完美解决了**两个链表长度不一致**导致无法同步到达交点的问题。

  这里没有复杂的“追及问题”（快慢指针），只有纯粹的**“路程相等”**数学原理。

  我们可以把它拆解为三个步骤来详细解释：

  ### 1. 拆解链表结构

  我们可以把两个链表拆分为三个部分来看：

  - **$a$**：链表 A 独有的部分（非公共部分）的长度。
  - **$b$**：链表 B 独有的部分（非公共部分）的长度。
  - **$c$**：两个链表相交后公共部分（包括交点）的长度。

  **此时结构如下：**

  - 链表 A 的总长度 = $a + c$
  - 链表 B 的总长度 = $b + c$

  如果 $a$ 和 $b$ 不相等（例如 A 短 B 长），两个指针同时出发，短的那个走完 $a$ 到达交点时，长的那个还在 $b$ 里面晃悠，它俩碰不到面。

  ### 2. 核心原理：拼接路径

  算法的逻辑是：当指针 `pA` 走到链表 A 的尽头（null）时，立刻跳到链表 B 的头；`pB` 同理。

  这就相当于我们在逻辑上构造了两条新的路径：

  - **路径 A'**：先走链表 A，再走链表 B。
  - **路径 B'**：先走链表 B，再走链表 A。

  让我们计算一下这两个指针在**相遇之前**走的距离：

  - **指针 `pA` 走的路线：**

    1. 走完 A 的独有区 ($a$)
    2. 走完公共区 ($c$) -> *此时到达末尾，跳到 B 头*
    3. 走完 B 的独有区 ($b$)
    4. **到达交点**

    - **总路程 = $a + c + b$**

  - **指针 `pB` 走的路线：**

    1. 走完 B 的独有区 ($b$)
    2. 走完公共区 ($c$) -> *此时到达末尾，跳到 A 头*
    3. 走完 A 的独有区 ($a$)
    4. **到达交点**

    - **总路程 = $b + c + a$**

  ### 3. 见证奇迹的时刻

  你会发现：

  

  $$a + c + b = b + c + a$$

  虽然 $a$ 和 $b$ 的长度不同，但是 **$a+b+c$ 的总长度是一定的**。

  - `pA` 指针补上了 B 链表的缺口 ($b$)。
  - `pB` 指针补上了 A 链表的缺口 ($a$)。

  效果：

  通过“互换跑道”，两个指针都正好走了 $a+b$ 步（非公共部分之和）加上 $c$ 步（或者在进入 $c$ 之前）。

  因为它们速度一致（一次一步），路程一致，所以它们会在第 $a+b+1$ 步的时候，同时迈进公共区域的大门（即相交节点）。

  ------

  ### 图解演示

  假设：

  - A链表（短）：`[1, 2]` -> `[8, 9]` (交点是8，a=2, c=2)
  - B链表（长）：`[3, 4, 5]` -> `[8, 9]` (交点是8，b=3, c=2)

  **过程如下：**

  | **步数** | **指针 pA 当前位置**   | **指针 pB 当前位置**   | **状态**                                   |
  | -------- | ---------------------- | ---------------------- | ------------------------------------------ |
  | 1        | 1 (A头)                | 3 (B头)                | 不相等                                     |
  | 2        | 2                      | 4                      | 不相等                                     |
  | 3        | 8 (进入公共区)         | 5                      | 不相等（此时A虽然到了交点，但B没到，错过） |
  | 4        | 9                      | 8 (B进入公共区)        | 不相等                                     |
  | 5        | null (A走完了)         | 9                      | A准备换道                                  |
  | 6        | **3 (跳到了B头)**      | null (B走完了)         | B准备换道                                  |
  | 7        | 4                      | **1 (跳到了A头)**      | 都在对方的独有区走                         |
  | 8        | 5                      | 2                      | 都在对方的独有区走                         |
  | 9        | **8 (再次进入公共区)** | **8 (再次进入公共区)** | **相遇！(pA == pB)**                       |

  可以看到，在第9步，两者同时指向了节点 8。

  ### 4. 特殊情况：如果不相交怎么办？

  如果两个链表完全不相交（没有公共部分 $c$），这个算法依然有效。

  - **$c = 0$**
  - `pA` 走的路程：A全长 + B全长
  - `pB` 走的路程：B全长 + A全长

  它们会在走完两个链表后，同时变成 null。

  代码中的 while (pA != pB) 会因为 null == null 而终止循环。

  最后返回 pA (也就是 null)，符合题目要求。

  ### 总结

  这个算法的本质不是“造环”，而是**“消除长度差”**。

  - 既然我比你短，你比我长。
  - 那我们约定：我跑完我的路，去跑你的路；你跑完你的路，来跑我的路。
  - 这样我们跑的总长度就绝对公平（一样长）了。
  - 最后我们在终点（交点）相见。

# 为什么相遇是第一个交点？

- 这是一个非常棒的追问！直觉上我们知道“路程相等”会让它们在某个时刻相遇，但为什么相遇点 **偏偏就是相交点（Intersection Node）**，而不是在半路上的某个随机节点呢？

  答案是：它们会在**第二次进入公共区域（Part c）的入口处**精准相遇。

  我们可以通过把两个指针的行走路线“拉直”并且“上下对齐”来看看：

  ### 1. 定义三段路程

  - **$a$**：链表 A 的独有部分。
  - **$b$**：链表 B 的独有部分。
  - **$c$**：公共相交部分（从相交点到结尾）。

  ### 2. 把时间轴对齐

  假设指针 A 和 指针 B 同时一步步走，我们把它们走过的路铺开来看：

  - **指针 A 的旅程：** 先走 $a$，再走 $c$，（换头），再走 $b$…… **到达终点**
  - **指针 B 的旅程：** 先走 $b$，再走 $c$，（换头），再走 $a$…… **到达终点**

  我们把这两条路线上下对齐：

  Plaintext

  ```
  时刻:      |---第一阶段---|-----第二阶段-----|---第三阶段---| -> 相遇时刻
  -----------------------------------------------------------------------
  指针 A:    [   走过 a   ] [    走过 c    ] [    走过 b    ] -> 停在 c 的入口
  指针 B:    [     走过 b     ] [    走过 c    ] [   走过 a   ] -> 停在 c 的入口
  ```

  ### 3. 为什么刚好停在 c 的入口？

  让我们看**指针 A** 在“第三阶段”发生了什么：

  1. 它已经走完了原来的链表 A（$a + c$）。
  2. 它跳到了链表 B 的头。
  3. 它在链表 B 上走了 $b$ 的距离（因为剩下的总路程限制，它只能再走 $b$ 步）。
  4. **关键点：** 在链表 B 上，从头开始走 $b$ 步，**正好就是走到相交点（c 的入口）！**

  同理看**指针 B**：

  1. 它跳到了链表 A 的头。
  2. 它在链表 A 上走了 $a$ 的距离。
  3. **关键点：** 在链表 A 上，从头开始走 $a$ 步，**也正好是走到相交点（c 的入口）！**

  ### 4. 结论

  它们相遇的位置，就是：

  指针 A 跑完 len(A) 后，再在 B 链表上跑 len(B) - len(Common) 的位置。

  指针 B 跑完 len(B) 后，再在 A 链表上跑 len(A) - len(Common) 的位置。

  这两个位置，在几何逻辑上，**绝对且唯一**地指向了**公共区域的起始点**。

  ### 极简总结

  - A 走了：**我自己的路 + 公共路 + 你的独有路**
  - B 走了：**你自己的路 + 公共路 + 我的独有路**

  因为“你的独有路”正是通往“公共路”的必经之路的前半段。所以走完它，必然一脚踏进公共路的大门（交点）。