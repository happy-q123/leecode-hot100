别担心，**这道题完全不需要你写复杂的自动平衡逻辑（如 AVL 树或红黑树的左旋、右旋）！**

你的直觉是对的，如果让你手动实现 AVL 树的旋转来做这道题，那确实太难了，通常是面试中的“地狱模式”。

但这道题有一个关键的**隐含条件**帮了你大忙：**输入数组已经是“升序排列”的**。

这意味着你不需要通过旋转来“调整”树的平衡，你只需要在**构建**树的时候，选对“根节点”，树天然就是平衡的。

### 核心思路：找中点

一棵**高度平衡**的二叉搜索树（BST），要求每个节点的左右子树高度差不超过 1。

在一个**有序数组**中，谁最适合做根节点？当然是**最中间的那个数**。

1. **中间的数**把数组分成了长度近乎相等的两半。
2. **左半边**的数都比它小 -> 放进**左子树**。
3. **右半边**的数都比它大 -> 放进**右子树**。
4. 因为左右两边的元素数量差不多，所以生成的左右子树高度也差不多 -> **天然平衡**。

### 举个栗子：`[-10, -3, 0, 5, 9]`

1. 数组长度是 5，中点是索引 `2`，也就是数值 **`0`**。
   - **根节点：0**
2. **左边部分**是 `[-10, -3]`。
   - 再找中点（比如选 `-3`），它变成 `0` 的左孩子。
   - 剩下 `[-10]` 变成 `-3` 的左孩子。
3. **右边部分**是 `[5, 9]`。
   - 再找中点（比如选 `9`），它变成 `0` 的右孩子。
   - 剩下 `[5]` 变成 `9` 的左孩子。

这就是经典的**分治法（Divide and Conquer）**，也就是**递归**。

------

### 代码实现 (Java)

我们直接用**递归**来写，代码非常短。

```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        // 调用辅助函数，传入数组的左右边界（闭区间）
        return helper(nums, 0, nums.length - 1);
    }

    private TreeNode helper(int[] nums, int left, int right) {
        // 递归终止条件：如果左边界大于右边界，说明没有元素了
        if (left > right) {
            return null;
        }

        // 1. 找中点
        // (left + right) / 2 可能会溢出，虽然这题数据规模不大，但这是个好习惯
        int mid = left + (right - left) / 2;

        // 2. 以中点的值创建当前根节点
        TreeNode root = new TreeNode(nums[mid]);

        // 3. 递归构建左子树（范围是左边界 到 中点-1）
        root.left = helper(nums, left, mid - 1);

        // 4. 递归构建右子树（范围是中点+1 到 右边界）
        root.right = helper(nums, mid + 1, right);

        // 5. 返回当前构建好的树
        return root;
    }
}
```

### 为什么这样做是对的？

- **二叉搜索树性质**：因为数组是有序的，我们把左半边放左边，右半边放右边，天然满足“左 < 根 < 右”。
- **平衡性**：因为我们要么选正中间，要么选中间偏左/偏右一点点（偶数长度时），左右两边的节点数量差永远不超过 1，所以高度差也就不会超过 1。

### 总结

这道题考查的不是“如何通过旋转来平衡”，而是**“二分查找”**思想在树构建中的应用。你只要记得：**有序数组的中点就是根**，然后递归处理两边即可。

这就把一个吓人的“树平衡”问题，变成了一个简单的“二分法”问题。

你想试试这道题的进阶版吗？比如**链表**转二叉搜索树（LeetCode 109），那个因为不能直接用下标访问中点，会稍微麻烦一点点。