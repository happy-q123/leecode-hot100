没关系，动态规划（Dynamic Programming, DP）的代码通常都很精简，但背后的逻辑往往很抽象，非常容易让人“绕进去”。

我们抛开复杂的数学术语，用一个**“填表游戏”**或者**“购物清单”**的例子来模拟这个过程。

### 1. 核心思维转换

首先，我们要把问题换个说法，不要想“两边差为0”，而是想：

“我有一个容量为 Target 的背包，我能不能从这些数字里挑出几个，刚好把背包装满？”

- 假设数组总和是 100，如果能凑出和为 50 的子集，那剩下的自然也是 50。
- 所以，目标变成：**能否凑出 `Target = Sum / 2`**。

------

### 2. 这个布尔数组 `dp` 是什么？

想象你有一张**“可能性清单”**（这就是 `boolean[] dp`）：

`dp` 数组的下标代表**“和”**，值代表**“能不能凑出来”**。

- `dp[0] = true`：凑出和为 0？可以（一个都不选就是 0）。
- `dp[5] = true`：凑出和为 5？可以。
- `dp[5] = false`：凑出和为 5？目前没法凑出来。

我们的目标是：最后看看 `dp[Target]` 是 true 还是 false。

------

### 3. 图解演示（重点）

假设数组是 nums = [1, 2, 3]。

总和是 6，目标 Target = 3。

我们要建立一个长度为 4 的数组（0, 1, 2, 3）。

#### **初始状态**

刚开始，我们手里什么数字都没有。

只有“和为 0”是可能的（什么都不拿）。

dp 数组：[True, False, False, False]

(索引：0, 1, 2, 3)

#### **第一轮：来了数字 1**

我们要看，加上 1 之后，能搞出什么新的“和”？

- 原来的 0 + 新来的 1 = **1**。
- 所以，我们把下标 1 的位置标记为 `True`。

dp 变成：[True, True, False, False]

(现在的意思是：我们可以凑出 0，也可以凑出 1)

#### **第二轮：来了数字 2**

我们在现有的基础上，再加 2，看看能凑出什么？

现有的可能： 0 和 1。

- 原来的 1 + 新来的 2 = **3**。（把下标 3 标为 True）
- 原来的 0 + 新来的 2 = **2**。（把下标 2 标为 True）

dp 变成：[True, True, True, True]

(现在的意思是：0, 1, 2, 3 都能凑出来)

**结果：** `dp[3]` 是 True，返回成功！

------

### 4. 为什么要“从后往前”遍历？（难点）

代码里最让人看不懂的通常是这行：

for (int j = target; j >= num; j--)

为什么要倒着数？

**如果不倒着数（从前往后），会发生什么错误？**

假设现在只有数字 2，目标是 4。

dp 初始：[True, False, False, False, False]

**错误演示（从前往后 j++）：**

1. j = 2 时：

   我们检查 dp[2 - 2] (即 dp[0])，它是 True。

   于是 dp[2] 变成了 True。

   (意思是：用这个 2，我们凑出了 2)

   dp: [True, False, True, False, False]

2. j = 4 时（还在同一轮循环里）：

   我们检查 dp[4 - 2] (即 dp[2])。

   注意！ dp[2] 刚刚被我们变成了 True。

   于是程序认为 dp[4] 也可以变成 True。

   (意思是：我们在 2 的基础上又加了一次 2，凑出了 4)

问题在哪？

那个数字 2 被用了两次！ 但题目规定每个数字只能用一次。

**正确演示（从后往前 j--）：**

1. j = 4 时：

   检查 dp[4 - 2] (即 dp[2])，它是 False。

   所以 dp[4] 还是 False。

2. j = 2 时：

   检查 dp[2 - 2] (即 dp[0])，它是 True。

   所以 dp[2] 变成 True。

**这就对了！** 倒着遍历，保证了我们在计算 `dp[j]` 时，引用的 `dp[j-num]` 是**上一轮**的状态（还没加过当前这个数字的状态），从而避免了一个数字被重复使用。

### 5. 代码翻译

现在再看一遍标准代码，应该会清晰很多：

Java

```
public boolean canPartition(int[] nums) {
    // 1. 算总和
    int sum = 0;
    for (int num : nums) sum += num;
    
    // 2. 奇数肯定不行
    if (sum % 2 != 0) return false;
    
    // 3. 目标是总和的一半
    int target = sum / 2;
    
    // 4. “可能性清单”，dp[i] 表示能不能凑出和为 i
    boolean[] dp = new boolean[target + 1];
    
    // 5. 初始化：凑出 0 总是可以的（什么都不拿）
    dp[0] = true;

    // 6. 遍历每一个硬币/数字
    for (int num : nums) {
        // 7. 倒着更新清单！
        // 只要 j 大于等于当前数字，就有可能由 (j - num) 加上 num 凑出来
        for (int j = target; j >= num; j--) {
            // dp[j] 的新状态 = 旧状态 OR (用了 num 之后的状态)
            // 意思是：如果不选 num 能凑出 j，或者选了 num 能凑出 j，那 j 就是可达成的
            if (dp[j - num] == true) {
                dp[j] = true;
            }
        }
    }

    return dp[target];
}
```

简单总结：**`dp` 数组就是一张不断更新的“清单”，我们拿着每个数字，试图去勾选清单上更多可能的格子。**