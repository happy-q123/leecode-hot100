“打家劫舍”（House Robber）是动态规划（Dynamic Programming, DP）中非常经典的一道入门题。它的核心在于**如何在有限制的条件下做出最优选择**。

以下我将从问题模型、思维推导、状态转移方程到代码实现，为你详细讲解其背后的原理。

------

### 1. 问题模型

场景： 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金。

约束： 相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

目标： 给定一个代表每个房屋存放金额的非负整数数组 nums，计算你 在不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

示例：

输入：[1, 2, 3, 1]

输出：4

解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4。

------

### 2. 核心思维：选与不选

面对第 $i$ 间房子，我们必须做一个决策，而这个决策取决于之前的状态。这正是动态规划的精髓：**重叠子问题**和**最优子结构**。

对于当前的第 $i$ 间房子（设金额为 $nums[i]$），我们只有两种选择：

1. **偷第 $i$ 间房：**
   - 如果我们决定偷这间房，那么根据“不能相邻”的规则，我们**绝对不能**偷第 $i-1$ 间房。
   - 这意味着，我们目前的总资产 = **偷完第 $i-2$ 间房所能得到的最高金额** + **第 $i$ 间房的金额**。
2. **不偷第 $i$ 间房：**
   - 如果我们放弃这间房，那么我们的收益就等于**偷完第 $i-1$ 间房所能得到的最高金额**（因为没有新增收益，直接继承之前的最优解）。

**我们的目标是：在这两种选择中，取最大值。**

------

### 3. 动态规划推导步骤

#### 第一步：定义状态（DP 数组）

我们需要一个数组 $dp$ 来记录过程中的最优解。

定义 $dp[i]$ 为：考虑前 $i$ 间房子（从下标 0 到 $i$）所能获得的最大金额。

#### 第二步：状态转移方程

根据上面的“选与不选”逻辑，我们可以写出数学公式：

$$dp[i] = \max(dp[i-1], \quad dp[i-2] + nums[i])$$

- $dp[i-1]$：代表**不偷**第 $i$ 间房（继承前 $i-1$ 间的最大值）。
- $dp[i-2] + nums[i]$：代表**偷**第 $i$ 间房（前 $i-2$ 间的最大值 + 当前房子的钱）。

#### 第三步：初始化（Base Case）

为了让公式跑起来，我们需要处理最开始的边界情况，防止数组越界：

1. 只有 1 间房 ($i=0$)： 没得选，只能偷它。

   

   $$dp[0] = nums[0]$$

2. 只有 2 间房 ($i=1$)： 不能同时偷，只能选金额较大的一间。

   

   $$dp[1] = \max(nums[0], nums[1])$$

------

### 4. 实例演练

假设数组为 `[2, 7, 9, 3, 1]`。

1. **$i=0$ (金额 2):**
   - $dp[0] = 2$。
2. **$i=1$ (金额 7):**
   - $dp[1] = \max(2, 7) = 7$。
3. **$i=2$ (金额 9):**
   - 选择 1：不偷它 $\rightarrow$ 继承 $dp[1]$ (7)。
   - 选择 2：偷它 $\rightarrow$ $dp[0] + 9 = 2 + 9 = 11$。
   - **$dp[2] = \max(7, 11) = 11$**。
4. **$i=3$ (金额 3):**
   - 选择 1：不偷它 $\rightarrow$ 继承 $dp[2]$ (11)。
   - 选择 2：偷它 $\rightarrow$ $dp[1] + 3 = 7 + 3 = 10$。
   - **$dp[3] = \max(11, 10) = 11$** (这里为了保住前面的 11，不得不放弃金额 3)。
5. **$i=4$ (金额 1):**
   - 选择 1：不偷它 $\rightarrow$ 继承 $dp[3]$ (11)。
   - 选择 2：偷它 $\rightarrow$ $dp[2] + 1 = 11 + 1 = 12$。
   - **$dp[4] = \max(11, 12) = 12$**。

最终结果为 **12**。

------

### 5. 代码实现

#### 标准 DP 数组版（空间复杂度 O(N)）

Python

```
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]

    # 初始化 dp 数组
    dp = [0] * len(nums)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])

    # 开始遍历
    for i in range(2, len(nums)):
        dp[i] = max(dp[i-1], dp[i-2] + nums[i])

    return dp[-1]
```

#### 空间优化版（空间复杂度 O(1)）

观察公式 $dp[i] = \max(dp[i-1], dp[i-2] + nums[i])$，我们发现计算当前状态只需要**前两个状态**。因此，不需要保存整个数组，只用两个变量滚动更新即可。

Python

```
def rob_optimized(nums):
    if not nums: return 0
    
    prev_max = 0  # 相当于 dp[i-2]
    curr_max = 0  # 相当于 dp[i-1]
    
    for money in nums:
        # 临时保存当前计算出的最优解
        temp = max(curr_max, prev_max + money)
        # 滚动变量
        prev_max = curr_max
        curr_max = temp
        
    return curr_max
```

### 总结

打家劫舍问题的本质是**在“当前收益”与“未来潜力”之间做权衡**。当你选择了当前的钱，就扼杀了相邻的潜力；当你放弃当前的钱，是为了保住更优的组合。

你需要我进一步讲解这个问题的变种，比如**“打家劫舍 II”（房子围成一圈）**或者**“打家劫舍 III”（房子是二叉树排列）**吗？