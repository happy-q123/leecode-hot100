# 思路

我们可以把这个贪心算法的核心逻辑称为**“能量圈扩张”**或者**“连续区间维护”**。

为了让你彻底理解“覆盖了即存在路径”的逻辑，我们不仅要看代码，还要看它背后的**区间数学原理**。

------

### 1. 核心模型：从“点”到“区间”的思维转变

你的 DFS 代码是典型的**“点”思维**：

- “我从点 A 跳到点 B，再从点 B 跳到点 C……”
- 这像是在迷宫里一条路走到黑，撞墙了再退回来。

贪心算法是**“区间”思维**：

- “我现在能到达的**最远边界**在哪里？”
- 它不关心具体怎么跳（是先跳 2 步再跳 3 步，还是先 3 后 2），它只关心**当前所有可能性的总和**覆盖了多大的范围。

### 2. 详细推导：为什么区间是连续的？

我们定义一个变量 `MaxReach`，表示**从起点 0 出发，所能触及的连续闭区间 $[0, \text{MaxReach}]$**。

#### 初始状态

你站在起点 `0`。

- 你肯定能到达 `0`。
- 当前区间：`[0, 0]`。
- `MaxReach = 0`。

#### 归纳过程（The Inductive Step）

假设我们当前的**安全区**是 `[0, R]`。这意味着，在这个范围内的**每一个整数点**，我们都有办法从起点跳过来。

现在，我们遍历这个区间里的每一个点 `i`（$0 \le i \le R$）。

当我们站在点 `i` 上，且 `nums[i] = k` 时，发生了什么？

1. **能力释放**：你可以从 `i` 跳跃到 `i+1`, `i+2`, ..., `i+k` 的任意位置。
2. **区间融合**：这相当于我们在原本的 `[0, R]` 基础上，接上了一段新的可达区间 `[i+1, i+k]`。

**关键逻辑来了：**

因为 `i` 必定在 `[0, R]` 内部（也就是 $i \le R$），所以新的区间 `[i+1, i+k]` 和旧的区间 `[0, R]` **一定会连在一起**（或者重叠），绝对不会断开。

- **旧范围**：`0 --------------- R`
- **新跳跃**：         `i ------------------ (i+k)`
- **合并后**：`0 -------------------------- (i+k)`

**结论**：

只要我们按顺序遍历 `i`，并且只在 `i <= MaxReach` 时处理，那么我们维护的永远是一个**从 0 开始的、连续不断的、没有空洞的区间**。

### 3. 可达性逻辑证明

你问的：“假如覆盖了 x，就至少存在一条路径可以达到 x，对吗？”

**证明如下：**

假设某一时刻，我们的最远距离被更新为了 `Target`。这通常是因为某个点 `P` 触发了这次更新，使得 `P + nums[P] >= Target`。

这就构成了**逆向的一条链**：

1. 要想去 `Target`，我只需要先到达点 `P`（因为 `P` 能覆盖 `Target`）。
2. 要想去点 `P`，因为 `P` 也在之前的覆盖范围内，说明之前一定有个点 `Q`，满足 `Q + nums[Q] >= P`。
3. 要想去点 `Q`……
4. ……
5. 一直回溯，最终一定能回到起点 `0`。

虽然贪心算法在这个过程中**丢弃**了具体的路径信息（比如它没记下来到底是 Q 还是 Z 让你到达了 P），但它通过数学上的不等式传递性，**保证了路径的存在性**。

### 4. 举例演示（可视化）

数组：`[2, 3, 1, 1, 4]`

**Step 1: 站在 index 0**

- `nums[0] = 2`。
- 我可以覆盖 `0 + 1` 和 `0 + 2`。
- 当前连续区间从 `[0, 0]` 扩展到 `[0, 2]`。
- **含义**：点 0, 1, 2 都是安全的，我都过得去。

**Step 2: 检查 index 1**

- `1` 在区间 `[0, 2]` 里吗？在。说明我们可以安全到达 `1`。
- `nums[1] = 3`。从 `1` 出发最远能跳到 `1 + 3 = 4`。
- **区间融合**：旧区间 `[0, 2]` 和新扩展区间 `[1, 4]` 合并。
- 当前连续区间扩展到 `[0, 4]`。
- **含义**：点 0, 1, 2, 3, 4 都是安全的。

**Step 3: 检查 index 2**

- `2` 在区间 `[0, 4]` 里吗？在。
- `nums[2] = 1`。最远跳到 `2 + 1 = 3`。
- `3` 小于当前的 `4`，所以最远边界不用更新。
- 区间还是 `[0, 4]`。

**...以此类推**

### 总结

这个算法之所以成立，是因为题目允许**“跳跃长度 $\le$ 最大长度”**。这让可达性变成了一个**连续的性质**，而不是离散的。

- 只要 `MaxReach >= 终点`，根据连续性，终点一定在可达区间内。
- 算法只判断“能不能到”，而省去了计算“具体怎么到”的开销，这就是它从指数级复杂度 $O(2^n)$ 降到线性复杂度 $O(N)$ 的原因。



# 变形题

这是一份完整的题目定义、你的解题思路总结，以及基于你思路实现的最终代码。你可以把它看作一道定制版的 LeetCode 题目。

------

### 题目：跳跃游戏 (偶数步限制版)

**题目描述：**

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的 **最大长度** 。

但是，这里有一个额外的限制：**你每次跳跃的步数必须是偶数**（即你可以跳 0, 2, 4... 步，但不能跳 1, 3, 5... 步）。

判断你是否能够到达数组的 **最后一个下标**。如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

> **输入：** nums = [5, 9, 2, 1, 4]
>
> **输出：** true
>
> **解释：**
>
> 1. 从下标 0 出发，nums[0]=5。允许跳跃的偶数步数为 0, 2, 4。
> 2. 选择跳 4 步，直接到达下标 4（最后一个下标）。成功。

**示例 2：**

> **输入：** nums = [3, 2, 1, 0, 4]
>
> **输出：** false
>
> **解释：**
>
> 1. 从下标 0 出发，nums[0]=3。允许跳跃偶数步数为 0, 2。
> 2. 跳 2 步到达下标 2。
> 3. 在下标 2，nums[2]=1。允许跳跃偶数步数仅为 0（即无法移动）。
> 4. 无法到达最后一个下标 4。

**示例 3（奇偶性检测）：**

> **输入：** nums = [2, 2, 2]
>
> **输出：** true
>
> **解释：** 数组长度为 3，最后一个下标是 2。从 0 跳 2 步可达。

**示例 4（不可达）：**

> **输入：** nums = [1, 2, 3, 4]
>
> **输出：** false
>
> **解释：** 数组长度为 4，最后一个下标是 3。
>
> 因为起点是偶数(0)，每次只走偶数步(Even)，位置永远是偶数(Even + Even = Even)。
>
> 永远无法到达奇数下标 3。

------

### 你的解题思路总结

**最核心思想：依然可以设置一个最远距离变量，比如他当前值为w，那么表示[0,w]的任何偶数值都是可达的。**

**核心思想：区间贪心（直接坐标系）**

1. **奇偶性预判**：

   由于起点是 `0`（偶数），且步长必须是偶数，根据数学性质 `偶数 + 偶数 = 偶数`，我们所在的下标永远是偶数。因此，如果 **最后一个下标是奇数**，直接判死刑，返回 `false`。

2. **偶数链的连续性**：

   我们维护一个变量 `rightmost`（最远可达下标）。

   若当前 `rightmost = w`，这意味着区间 `[0, w]` 内的 **所有偶数下标** 都是我们能够到达的。

   - *原理*：因为每个位置允许跳跃 `0, 2, 4...` 等所有小于等于最大值的偶数步，这保证了偶数路径之间没有“空洞”。

3. **贪心扩充**：

   我们只遍历数组中的 **偶数下标** `i`（0, 2, 4...）：

   - 如果 `i` 在 `rightmost` 范围内（说明能跳到这里），我们就计算这里能贡献的新射程。
   - 该位置的有效跳跃力 = `(nums[i] / 2) * 2` （即向下取整到最近的偶数）。
   - 更新 `rightmost = max(rightmost, i + 有效跳跃力)`。

------

### 代码实现 (Java)

完全按照你的“直接维护最远距离”的思路编写，简洁明了：



```Java
class Solution {
    public boolean canJumpEven(int[] nums) {
        int n = nums.length;
        int target = n - 1;

        // 【思路第一步】
        // 预判：如果终点下标是奇数，绝对无法到达
        // 原理：偶数起点 + 偶数步长 永远 != 奇数终点
        if (target % 2 != 0) {
            return false;
        }

        // 【思路第二步】
        // rightmost 代表当前能覆盖到的最远距离
        // 这里的含义是：[0, rightmost] 范围内所有的 *偶数下标* 都是可达的
        int rightmost = 0;

        // 【思路第三步】
        // 只需要遍历偶数下标：0, 2, 4 ...
        for (int i = 0; i <= rightmost && i < n; i += 2) {
            
            // 计算当前位置 i 能提供的最大“偶数”跳跃长度
            // 例如：nums[i]=5，5/2=2，2*2=4。有效跳跃长度为 4。
            int currentMaxEvenJump = (nums[i] / 2) * 2;

            // 贪心策略：更新最远能到达的范围
            rightmost = Math.max(rightmost, i + currentMaxEvenJump);

            // 剪枝：如果已经覆盖了终点，直接返回 true
            if (rightmost >= target) {
                return true;
            }
        }

        // 循环结束还没有返回 true，说明 rightmost 没能触及 target
        // 或者在这个过程中断链了（循环条件 i <= rightmost 使得循环提前终止）
        return false;
    }
}
```

### 代码逻辑验证

- **输入**：`[5, 2, 1, 0, 4]` (终点下标 4)
- **Init**：`rightmost = 0`
- **i = 0**：
  - `0 <= 0` (成立)
  - `nums[0] = 5` -> 有效偶数步 `4`。
  - `rightmost = max(0, 0 + 4) = 4`。
  - `4 >= 4` (成立)，**返回 true**。
- **输入**：`[3, 2, 1, 0, 4]` (终点下标 4)
- **Init**：`rightmost = 0`
- **i = 0**:
  - `0 <= 0` (成立)
  - `nums[0] = 3` -> 有效偶数步 `2`。
  - `rightmost = max(0, 0 + 2) = 2`。
- **i = 2**:
  - `2 <= 2` (成立)
  - `nums[2] = 1` -> 有效偶数步 `0`。
  - `rightmost = max(2, 2 + 0) = 2`。
- **i = 4**:
  - `4 <= 2` (**不成立**！循环终止)。
- **返回 false**。

代码逻辑非常严密，完美对应了你的想法。