这是一个非常经典的**动态规划 (Dynamic Programming, DP)** 问题。

解决这类问题的关键在于将大问题分解为小问题，并找到它们之间的联系。对于“最长递增子序列” (LIS)，我们通常采用以下思路来推导状态方程。

### 1. 如何定义状态 ($dp[i]$)

我们在寻找状态定义时，通常会思考：**“如果我知道了前面的信息，我怎么推导出当前的信息？”**

对于子序列问题，关键在于子序列的**结尾元素**。因为我们要保证“严格递增”，所以能不能把当前元素 `nums[i]` 接在前面的子序列后面，取决于前面子序列的最后一个数值是否小于 `nums[i]`。

因此，我们定义状态 $dp[i]$ 为：

> **以数组中第 $i$ 个元素 (`nums[i]`) 为结尾的最长严格递增子序列的长度。**

**注意：** 这里强制要求子序列必须以 `nums[i]` 结束，这样我们在处理后面的元素时，就有了一个明确的比较对象。

### 2. 如何寻找状态转移方程

现在我们来到了第 $i$ 个位置，我们要计算 $dp[i]$。

我们要回头看 $i$ 之前的所有位置 $j$ (其中 $0 \leq j < i$)：

1. **比较：** 如果 `nums[i]` > `nums[j]`，说明 `nums[i]` 可以接在以 `nums[j]` 结尾的子序列后面，形成一个更长的递增子序列。
2. **计算长度：** 如果接上了，新的长度就是 $dp[j] + 1$。
3. **取最大值：** 因为 $i$ 前面可能有很多个比 `nums[i]` 小的元素，我们要从中挑一个能让序列最长的。

**状态转移方程：**

$$dp[i] = \max(dp[j]) + 1$$

其中 $0 \leq j < i$ 且 $nums[j] < nums[i]$。

初始条件 (Base Case)：

对于每一个 $i$，最短的递增子序列就是它自己本身，长度为 1。所以初始化时，每个 $dp[i] = 1$。

### 3. 图解与示例推导

让我们用示例 1 来手动推导一遍：`nums = [10, 9, 2, 5, 3, 7, 101, 18]`

初始化 $dp$ 数组全为 1。

- **i = 0, nums[0] = 10:**
  - 前面没有元素，$dp[0] = 1$。
- **i = 1, nums[1] = 9:**
  - 比较 $j=0$: 9 < 10 (不能接)。
  - $dp[1] = 1$。
- **i = 2, nums[2] = 2:**
  - 比较 10, 9... 都比 2 大。
  - $dp[2] = 1$。
- **i = 3, nums[3] = 5:**
  - 比较 2 (位置 2): 5 > 2，可以接！长度变为 $dp[2] + 1 = 2$。
  - $dp[3] = 2$。
- **i = 4, nums[4] = 3:**
  - 比较 2 (位置 2): 3 > 2，可以接！长度变为 $dp[2] + 1 = 2$。
  - $dp[4] = 2$。
- **i = 5, nums[5] = 7:**
  - 比较 2: 7 > 2 -> 长度 2。
  - 比较 5: 7 > 5 -> 长度 $dp[3] + 1 = 3$。
  - 比较 3: 7 > 3 -> 长度 $dp[4] + 1 = 3$。
  - 最大值 $dp[5] = 3$ (例如子序列 [2, 5, 7] 或 [2, 3, 7])。
- **...以此类推**

最终结果不是 $dp$ 数组的最后一个值，而是 **$dp$ 数组中的最大值**。

### 4. 代码实现 (Python)

Python

```
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
            
        # 1. 初始化 dp 数组，每个元素最少长度为 1 (它自己)
        dp = [1] * len(nums)
        
        # 2. 遍历每一个元素 i
        for i in range(len(nums)):
            # 3. 遍历 i 之前的所有元素 j
            for j in range(i):
                # 4. 如果发现递增关系
                if nums[i] > nums[j]:
                    # 5. 更新状态方程：取当前长度和 (之前的长度+1) 中的较大者
                    dp[i] = max(dp[i], dp[j] + 1)
        
        # 6. 结果是 dp 数组中的最大值，而不是最后一个值
        return max(dp)
```

### 复杂度分析

- **时间复杂度：** $O(n^2)$。我们需要两层循环，外层遍历 $i$，内层遍历 $j$。
- **空间复杂度：** $O(n)$。需要一个 `dp` 数组来存储状态。

------

进阶提示：

虽然 $O(n^2)$ 是标准的动态规划解法，但这道题其实存在一种利用 贪心 + 二分查找 的 $O(n \log n)$ 解法。

你想了解那个更高效的解法吗？这通常是面试中的加分项。