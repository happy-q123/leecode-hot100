没问题，我们来一次**像素级**的推演。

**输入数据：**

- `text1` = "ABCD" (长度 $m=4$)
- `text2` = "ACED" (长度 $n=4$)

**初始化 DP 表：**

大小为 $5 \times 5$（多一行一列处理空串），初始全为 0。

表头说明：

- **行 ($i$)** 代表 `text1`："A", "B", "C", "D"
- **列 ($j$)** 代表 `text2`："A", "C", "E", "D"

------

### 初始状态 (第 0 行/列全是 0)

|                 | **∅** | **A** | **C** | **E** | **D** |
| --------------- | ----- | ----- | ----- | ----- | ----- |
| **$\emptyset$** | 0     | 0     | 0     | 0     | 0     |
| **A**           | 0     | 0     | 0     | 0     | 0     |
| **B**           | 0     | 0     | 0     | 0     | 0     |
| **C**           | 0     | 0     | 0     | 0     | 0     |
| **D**           | 0     | 0     | 0     | 0     | 0     |

------

### 第一轮：处理 text1 的 'A' (i=1)

**目标：** 填满第 1 行。

1. **j=1 ('A')**:
   - `text1`('A') == `text2`('A') -> **相等！**
   - 逻辑：`dp[1][1] = dp[0][0] (左上) + 1` = $0 + 1 = 1$。
2. **j=2 ('C')**:
   - 'A' != 'C' -> 不等。
   - 逻辑：`max(dp[0][2](上), dp[1][1](左))` = `max(0, 1) = 1`。
3. **j=3 ('E')**:
   - 'A' != 'E' -> 不等。
   - 逻辑：`max(0, 1) = 1`。
4. **j=4 ('D')**:
   - 'A' != 'D' -> 不等。
   - 逻辑：`max(0, 1) = 1`。

**第一轮结束后的矩阵：**

(注意：这一行变成了全 1，因为只要有了 'A'，后面无论跟什么，公共子序列至少都是 1)

|                 | **∅** | **A** | **C** | **E** | **D** |
| --------------- | ----- | ----- | ----- | ----- | ----- |
| **$\emptyset$** | 0     | 0     | 0     | 0     | 0     |
| **A**           | 0     | **1** | **1** | **1** | **1** |
| **B**           | 0     | 0     | 0     | 0     | 0     |
| **C**           | 0     | 0     | 0     | 0     | 0     |
| **D**           | 0     | 0     | 0     | 0     | 0     |

------

### 第二轮：处理 text1 的 'B' (i=2)

**目标：** 填满第 2 行。

1. **j=1 ('A')**:
   - 'B' != 'A'。
   - `max(dp[1][1](上), dp[2][0](左))` = `max(1, 0) = 1`。
2. **j=2 ('C')**:
   - 'B' != 'C'。
   - `max(dp[1][2](上), dp[2][1](左))` = `max(1, 1) = 1`。
3. **j=3 ('E')**:
   - 'B' != 'E'。
   - `max(dp[1][3](上), dp[2][2](左))` = `max(1, 1) = 1`。
4. **j=4 ('D')**:
   - 'B' != 'D'。
   - `max(dp[1][4](上), dp[2][3](左))` = `max(1, 1) = 1`。

**第二轮结束后的矩阵：**

(注意：'B' 没有在这个序列中找到匹配，所以它只是继承了上一行的战果)

|                 | **∅** | **A** | **C** | **E** | **D** |
| --------------- | ----- | ----- | ----- | ----- | ----- |
| **$\emptyset$** | 0     | 0     | 0     | 0     | 0     |
| **A**           | 0     | 1     | 1     | 1     | 1     |
| **B**           | 0     | **1** | **1** | **1** | **1** |
| **C**           | 0     | 0     | 0     | 0     | 0     |
| **D**           | 0     | 0     | 0     | 0     | 0     |

------

### 第三轮：处理 text1 的 'C' (i=3)

**目标：** 填满第 3 行。

1. **j=1 ('A')**:
   - 'C' != 'A'。
   - `max(dp[2][1](上), dp[3][0](左))` = `max(1, 0) = 1`。
2. **j=2 ('C')**:
   - `text1`('C') == `text2`('C') -> **相等！** (关键点)
   - 逻辑：`dp[3][2] = dp[2][1] (左上) + 1`。
   - 查表可知 `dp[2][1]` 是 1。
   - 结果：$1 + 1 = 2$。
3. **j=3 ('E')**:
   - 'C' != 'E'。
   - `max(dp[2][3](上), dp[3][2](左))` = `max(1, 2) = 2`。
   - (这里继承了刚才找到的长度 2)
4. **j=4 ('D')**:
   - 'C' != 'D'。
   - `max(dp[2][4](上), dp[3][3](左))` = `max(1, 2) = 2`。

**第三轮结束后的矩阵：**

(注意：我们在 C 处找到了第二个公共字符，长度变成了 2)

|                 | **∅** | **A** | **C** | **E** | **D** |
| --------------- | ----- | ----- | ----- | ----- | ----- |
| **$\emptyset$** | 0     | 0     | 0     | 0     | 0     |
| **A**           | 0     | 1     | 1     | 1     | 1     |
| **B**           | 0     | 1     | 1     | 1     | 1     |
| **C**           | 0     | 1     | **2** | **2** | **2** |
| **D**           | 0     | 0     | 0     | 0     | 0     |

------

### 第四轮：处理 text1 的 'D' (i=4)

**目标：** 填满第 4 行。

1. **j=1 ('A')**:
   - 'D' != 'A'。`max(1, 0) = 1`。
2. **j=2 ('C')**:
   - 'D' != 'C'。`max(2, 1) = 2`。
3. **j=3 ('E')**:
   - 'D' != 'E'。`max(2, 2) = 2`。
4. **j=4 ('D')**:
   - `text1`('D') == `text2`('D') -> **相等！** (关键点)
   - 逻辑：`dp[4][4] = dp[3][3] (左上) + 1`。
   - 查表可知 `dp[3][3]` 是 2。
   - 结果：$2 + 1 = 3$。

**最终矩阵：**

|                 | **∅** | **A** | **C** | **E** | **D** |
| --------------- | ----- | ----- | ----- | ----- | ----- |
| **$\emptyset$** | 0     | 0     | 0     | 0     | 0     |
| **A**           | 0     | 1     | 1     | 1     | 1     |
| **B**           | 0     | 1     | 1     | 1     | 1     |
| **C**           | 0     | 1     | 2     | 2     | 2     |
| **D**           | 0     | 1     | 2     | 2     | **3** |

**最终结果：** 右下角的 **3**。

解释：最长公共子序列是 "A" -> "C" -> "D"。