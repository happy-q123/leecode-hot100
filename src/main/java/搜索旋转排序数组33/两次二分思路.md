这是一个非常棒的切入点！**“寻找旋转排序数组中的最小值”** 本身就是一道独立的 LeetCode 题目（题号 153）。

只要找到了这个最小值（旋转点，Pivot），这道题就变成了：“在一个已知分界点的数组中，选一边进行普通的二分查找”。

### 第一步：如何用二分法找最小值？

在旋转数组中，图形大概是这样的：先上升，突然掉下来（悬崖），再上升。**最小值就是那个掉下来的点。**

#### 核心逻辑

我们需要拿 `nums[mid]` 和 **`nums[right]`**（右边界）做比较：

1. **若 `nums[mid] > nums[right]**`：
* 说明 `mid` 在左半边的“高台”上，比如 `[4,5,6, 0,1,2]`，`mid=6`，`right=2`。
* 最小值肯定在 `mid` 的**右边**。
* 操作：`left = mid + 1`


2. **若 `nums[mid] < nums[right]**`：
* 说明 `mid` 在右半边的“低谷”里，或者数组本身就是有序的。比如 `[6,0, 1, 2]`，`mid=1`，`right=2`。
* 最小值可能是 `mid` 自己，也可能在 `mid` 的**左边**。
* 操作：`right = mid` （**注意：** 这里不能减 1，因为 `mid` 可能就是最小值）


3. **循环条件**：
* 使用 `while (left < right)`。当 `left == right` 时，循环结束，`left` 就是最小值的索引。



---

### 完整代码：两次二分法

这里是完整的代码实现。这种写法的逻辑非常清晰：**找基准 -> 选区间 -> 查目标**。

```java
package 搜索旋转排序数组33;

public class SolutionTwiceBinary {

    public static void main(String args[]) {
        int[] nums = {4, 5, 6, 7, 0, 1, 2};
        int target = 4;
        int result = new SolutionTwiceBinary().search(nums, target);
        System.out.println("Result index: " + result);
    }

    public int search(int[] nums, int target) {
        if (nums.length == 0) return -1;
        if (nums.length == 1) return nums[0] == target ? 0 : -1;

        // 步骤 1: 第一次二分，找到最小值的索引 (旋转点)
        int pivotIndex = findMinIndex(nums);

        // 步骤 2: 根据 target 和 pivot 的值，判断 target 在哪个有序区间
        // 旋转点将数组分为：[0, pivotIndex-1] 和 [pivotIndex, length-1]
        
        // 如果 pivotIndex 是 0，说明数组没旋转（或旋转了n次），直接查整个数组
        if (pivotIndex == 0) {
            return binarySearch(nums, 0, nums.length - 1, target);
        }

        // 判断 target 属于哪一段
        // 比较 target 和 数组最后一个元素（或第一个元素）来决定
        if (target >= nums[pivotIndex] && target <= nums[nums.length - 1]) {
            // target 在右半段（较小的那段）
            return binarySearch(nums, pivotIndex, nums.length - 1, target);
        } else {
            // target 在左半段（较大的那段）
            return binarySearch(nums, 0, pivotIndex - 1, target);
        }
    }

    /**
     * 第一次二分：寻找旋转排序数组的最小值索引
     */
    private int findMinIndex(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        while (left < right) { // 注意这里没有 =
            int mid = left + (right - left) / 2;
            
            if (nums[mid] > nums[right]) {
                // mid 在左半段高位，最小值肯定在 mid 右边
                left = mid + 1;
            } else {
                // mid 在右半段低位，mid 可能是最小值，也可能在左边
                right = mid;
            }
        }
        return left; // 循环结束时 left == right，指向最小值
    }

    /**
     * 第二次二分：标准的二分查找
     */
    private int binarySearch(int[] nums, int left, int right, int target) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
}

```

### 代码解析：为什么要比较 `nums[right]`？

你可能会问，为什么找最小值时要和 `right` 比，而不是和 `left` 比？

* **如果和 `left` 比**：
* `[1, 2, 3]` (正常)：`nums[mid] > nums[left]`
* `[3, 4, 5, 1, 2]` (旋转)：`nums[mid] > nums[left]`
* **结论**：不管是否旋转，`nums[mid]` 都可能大于 `nums[left]`，这无法帮我们要排除哪一半。


* **如果和 `right` 比**：
* `[1, 2, 3]` (正常)：`nums[mid] < nums[right]`  往左找。
* `[3, 4, 5, 1, 2]` (旋转)：`nums[mid] > nums[right]`  出现了“断崖”，最小值一定在右边。
* **结论**：和 `right` 比较能准确判断 `mid` 是在“左边高坡”还是“右边低谷”。



这种“两次二分”的写法在工程上其实很好，因为它把**找最小值**和**查找目标**解耦了，逻辑更不容易出错。