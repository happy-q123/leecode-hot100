你的思路非常直观，这是典型的求解“最大子数组和”（Kadane算法）的思路。对于**加法**问题，你的方程 `d[p] = max(n[p], d[p-1] + n[p])` 是完全正确的。

但在**乘法**问题中，你的状态转移方程 `d[p] = max(d[p-1], d[p-1] * n[p])` 有一个**致命的漏洞**。

### 漏洞在哪里？

**乘法最怕负负得正。**

假如数组是 `[-2, 3, -4]`：

1. **第一步** (`-2`)：最大乘积是 **-2**。
2. **第二步** (`3`)：`-2 * 3 = -6`，比 `3` 小，所以当前最大是 **3**。
   - 此时按照你的逻辑，你丢弃了 `-6`，只记住了 `3`。
3. **第三步** (`-4`)：
   - 如果用你的逻辑：`max(3, 3 * -4)` -> 结果是 `3` (因为 -12 更小)。
   - **但实际上**：如果我们保留了之前的那个 `-6`（也就是最小值），`(-6) * (-4)` 就会变成 **24**！这是真正的最大值。

结论：

当 nums[i] 是负数时，它会将前面积累的最大值变成最小值，也会把前面的最小值变成最大值。

------

### 如何修正？（双向 DP）

既然负数会让最大变最小、最小变最大，那我们只维护一个 `D[p]` 是不够的。我们需要同时维护两个状态数组：

1. `maxDP[i]`：以 `i` 结尾的连续子数组的**最大乘积**。
2. `minDP[i]`：以 `i` 结尾的连续子数组的**最小乘积**（为了等下一个负数把它变成超级大的正数）。

#### 状态转移方程

对于每一个数 `nums[i]`，最大值可能来自三种情况：

1. 当前的数自己（前面的断开了，从头开始）：`nums[i]`
2. 前面的最大值乘当前数（正正得正）：`maxDP[i-1] * nums[i]`
3. 前面的最小值乘当前数（负负得正）：`minDP[i-1] * nums[i]`

所以方程变成了：



$$maxDP[i] = \max(nums[i], \ maxDP[i-1] \times nums[i], \ minDP[i-1] \times nums[i])$$

$$minDP[i] = \min(nums[i], \ maxDP[i-1] \times nums[i], \ minDP[i-1] \times nums[i])$$

*注意：`nums[i]` 单独存在也是一种情况（比如前面算出来是 0，或者前面特别小，不如重新开始）。*

------

### 代码实现 (Java)

不需要开很大的数组，因为 `i` 只和 `i-1` 有关，用变量滚动更新即可。

Java

```
public int maxProduct(int[] nums) {
    if (nums.length == 0) return 0;

    int maxF = nums[0]; // 维护当前位置的最大值
    int minF = nums[0]; // 维护当前位置的最小值
    int ans = nums[0];  // 记录全局最大值

    for (int i = 1; i < nums.length; i++) {
        int mx = maxF;
        int mn = minF;
        
        // 由于 maxF 会在第一行被更新，所以计算 minF 时要用旧的 mx
        // 这里为了清晰，直接在 max/min 函数里把三种情况都放进去
        
        maxF = Math.max(mx * nums[i], Math.max(nums[i], mn * nums[i]));
        minF = Math.min(mn * nums[i], Math.min(nums[i], mx * nums[i]));
        
        // 更新全局答案
        ans = Math.max(ans, maxF);
    }
    
    return ans;
}
```

### 总结

这道题的题眼就在于**“负负得正”**。

- 如果是**求和**，只要盯着最大值就行。
- 如果是**求积**，必须同时盯着**最大值**和**最小值**，因为最小值可能随时翻身做主人。

这个思路能理解吗？